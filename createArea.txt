import React, { useState, useEffect, useRef, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { useDebouncedCallback } from 'use-debounce';
import clsx from 'clsx';
import ReminderPicker from './ReminderPicker';
import ImageUpload from './ImageUpload';
import DrawingCanvas from './DrawingCanvas';
import {
  Pin,
  Bell,
  UserPlus,
  Image as ImageIcon,
  Archive,
  Trash2,
  MoreVertical,
  Undo,
  Redo,
  Bold,
  Italic,
  Underline,
  Palette,
  List,
  X,
  CheckSquare,
  Type,
  Edit3,
  Plus
} from 'lucide-react';

/*****************************************************************
 * Constants & helpers
 *****************************************************************/
const BLOCK_TYPES = {
  TEXT: 'text',
  CHECKLIST: 'checklist',
  IMAGE: 'image',
  DRAWING: 'drawing',
};
const generateId = () => '_' + Math.random().toString(36).slice(2, 9);
const createEmptyBlock = (type) => {
  switch (type) {
    case BLOCK_TYPES.TEXT:
      return { id: generateId(), type: BLOCK_TYPES.TEXT, data: '' };
    case BLOCK_TYPES.CHECKLIST:
      return { id: generateId(), type: BLOCK_TYPES.CHECKLIST, data: [] };
    case BLOCK_TYPES.IMAGE:
      return { id: generateId(), type: BLOCK_TYPES.IMAGE, data: null };
    case BLOCK_TYPES.DRAWING:
      return { id: generateId(), type: BLOCK_TYPES.DRAWING, data: null };
    default:
      return createEmptyBlock(BLOCK_TYPES.TEXT);
  }
};

/*****************************************************************
 * Root component
 *****************************************************************/
export default function NoteEditor({
  initialNote,
  onSave,
  onCancel,
  onDelete,
  darkMode,
  isModal = false,
  onLabelsChange,
  currentLabel,
  allLabels,
  setAllLabels,
  noteType
}) {
  /* ---------- state ---------- */
  const [note, setNote] = useState(() => {
    const fallback = {
      id: null,
      title: '',
      blocks: [createEmptyBlock(noteType || BLOCK_TYPES.TEXT)],
      color: darkMode ? '#202124' : '#ffffff',
      labels: [],
      reminder: null,
      collaborators: [],
      status: 'active',
      pinned: false,
      lastModified: new Date(),
      contentChanged: false,
    };
    if (!initialNote) return fallback;
    return { ...fallback, ...initialNote };
  });

  useEffect(() => {
    if (initialNote) {
      setNote((prevNote) => {
        if (!prevNote.id || prevNote.id !== initialNote.id) {
          const fallback = {
            id: null,
            title: '',
            blocks: [createEmptyBlock(noteType || BLOCK_TYPES.TEXT)],
            color: darkMode ? '#202124' : '#ffffff',
            labels: [],
            reminder: null,
            collaborators: [],
            status: 'active',
            pinned: false,
            lastModified: new Date(),
            contentChanged: false,
          };

          let blocks = initialNote.blocks;
          if (!blocks || blocks.length === 0) {
            blocks = [createEmptyBlock(noteType || BLOCK_TYPES.TEXT)];
            if (initialNote.content) {
              blocks[0].data = initialNote.content;
            }
          }
          return { ...fallback, ...initialNote, blocks };
        }
        return prevNote;
      });
    }
  }, [initialNote, darkMode, noteType]);

  const [showReminderPicker, setShowReminderPicker] = useState(false);
  const [editLabelsModalOpen, setEditLabelsModalOpen] = useState(false);
  const [selectedLabels, setSelectedLabels] = useState(note.labels || []);
  const [showMoreOptions, setShowMoreOptions] = useState(false);
  const [formatting, setFormatting] = useState({
    bold: false,
    italic: false,
    underline: false,
    header: null,
  });

  useEffect(() => {
    if (initialNote && initialNote.labels) {
      setSelectedLabels(initialNote.labels);
    }
  }, [initialNote]);

  /* ---------- autosave ---------- */
  const debouncedSave = useDebouncedCallback(() => {
    if (note.contentChanged) {
      onSave?.({
        ...note,
        contentChanged: false,
        lastModified: new Date(),
        labels: selectedLabels
      });
      setNote((n) => ({ ...n, contentChanged: false }));
    }
  }, 1200);

  useEffect(() => {
    debouncedSave();
  }, [note, debouncedSave, selectedLabels]);

  /* ---------- updaters ---------- */
  const update = (updater) =>
    setNote((n) => ({ ...updater(n), contentChanged: true }));

  const updateTitle = (title) => update((n) => ({ ...n, title }));

  const updateBlock = (blockId, data) =>
    update((n) => ({
      ...n,
      blocks: n.blocks.map((b) => (b.id === blockId ? { ...b, data } : b)),
    }));

  const addBlock = (type, index) =>
    update((n) => ({
      ...n,
      blocks: [
        ...n.blocks.slice(0, index + 1),
        createEmptyBlock(type),
        ...n.blocks.slice(index + 1),
      ],
    }));

  const removeBlock = (blockId) =>
    update((n) => ({ ...n, blocks: n.blocks.filter((b) => b.id !== blockId) }));

  const splitBlock = (index, textAfter) =>
    update((n) => {
      const newBlocks = [...n.blocks];
      newBlocks.splice(index + 1, 0, createEmptyBlock(BLOCK_TYPES.TEXT));
      newBlocks[index].data = newBlocks[index].data.slice(
        0,
        newBlocks[index].data.length - textAfter.length
      );
      newBlocks[index + 1].data = textAfter;
      return { ...n, blocks: newBlocks };
    });

  /* ---------- handlers ---------- */
  const handleSetReminder = (date) => {
    setNote(prev => ({ ...prev, reminder: date }));
    setShowReminderPicker(false);
  };

  const removeReminder = () => {
    setNote(prev => ({ ...prev, reminder: null }));
  };

  const handleLabelsChange = (labels) => {
    setSelectedLabels(labels);
  };

  const toggleFormatting = (type) => {
    setFormatting(prev => ({ ...prev, [type]: !prev[type] }));
  };

  const applyHeaderFormat = (level) => {
    setFormatting(prev => ({
      ...prev,
      header: level,
    }));
  };

  const clearFormatting = () => {
    setFormatting({
      bold: false,
      italic: false,
      underline: false,
      header: null,
    });
  };

  const handleAddBlock = (type) => {
    addBlock(type, note.blocks.length - 1);
  };

  /* ---------- render ---------- */
  return (
    <div
      className={clsx(
        'note-editor relative flex flex-col w-full',
        isModal ? 'max-w-none' : 'max-w-2xl mx-auto',
        isModal ? 'space-y-4' : 'space-y-3',
        isModal ? '' : 'rounded-lg shadow-lg max-h-[90vh] overflow-y-auto',
        isModal ? '' : (darkMode ? 'bg-[#202124] text-[#bdc1c6]' : 'bg-white text-[#202124]')
      )}
      style={isModal ? {} : { backgroundColor: note.color }}
    >
      {/* Title and Pin */}
      <div className="flex justify-between items-center mb-2">
        <TitleField
          value={note.title}
          onChange={updateTitle}
          darkMode={darkMode}
        />
        <button
          onClick={() => setNote((n) => ({ ...n, pinned: !n.pinned }))}
          className={clsx(
            'ml-2 p-2 rounded-full transition-all transform hover:scale-110',
            note.pinned ? 'text-yellow-500' : darkMode ? 'text-gray-400' : 'text-gray-500'
          )}
          aria-label={note.pinned ? 'Unpin note' : 'Pin note'}
          title={note.pinned ? 'Unpin note' : 'Pin note'}
        >
          <Pin className={`w-5 h-5 ${note.pinned ? 'fill-current' : ''}`} />
        </button>
      </div>

      {/* Blocks */}
      <div className="blocks space-y-2">
        {note.blocks.map((block, idx) => (
          <React.Fragment key={block.id}>
            <Block
              block={block}
              onUpdate={(data) => updateBlock(block.id, data)}
              onRemove={() => removeBlock(block.id)}
              onSplit={(textAfter) => splitBlock(idx, textAfter)}
              darkMode={darkMode}
              formatting={formatting}
              toggleFormatting={toggleFormatting}
              applyHeaderFormat={applyHeaderFormat}
              clearFormatting={clearFormatting}
            />
            {idx < note.blocks.length - 1 && (
              <AddBetween
                index={idx}
                onAdd={(type) => addBlock(type, idx)}
                darkMode={darkMode}
              />
            )}
          </React.Fragment>
        ))}
      </div>

      {/* Toolbar */}
      <div className={`flex flex-wrap items-center gap-2 mt-3 p-2 rounded-lg ${darkMode ? 'bg-gray-800/50' : 'bg-gray-100/50'
        }`}>
        {/* Text Formatting */}
        <div className="flex items-center space-x-1">
          <button
            type="button"
            aria-label="Bold"
            className={`p-2 rounded-full transition ${formatting.bold
                ? darkMode ? 'bg-blue-600 text-white' : 'bg-blue-500 text-white'
                : darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            onClick={() => toggleFormatting('bold')}
            title="Bold"
          >
            <Bold className="w-4 h-4" />
          </button>

          <button
            type="button"
            aria-label="Italic"
            className={`p-2 rounded-full transition ${formatting.italic
                ? darkMode ? 'bg-blue-600 text-white' : 'bg-blue-500 text-white'
                : darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            onClick={() => toggleFormatting('italic')}
            title="Italic"
          >
            <Italic className="w-4 h-4" />
          </button>

          <button
            type="button"
            aria-label="Underline"
            className={`p-2 rounded-full transition ${formatting.underline
                ? darkMode ? 'bg-blue-600 text-white' : 'bg-blue-500 text-white'
                : darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            onClick={() => toggleFormatting('underline')}
            title="Underline"
          >
            <Underline className="w-4 h-4" />
          </button>
        </div>

        <div className="h-6 w-px bg-gray-300 dark:bg-gray-600"></div>

        {/* Block Types */}
        <div className="flex items-center space-x-1">
          <button
            type="button"
            aria-label="Add text"
            className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            onClick={() => handleAddBlock(BLOCK_TYPES.TEXT)}
            title="Add text"
          >
            <Type className="w-4 h-4" />
          </button>

          <button
            type="button"
            aria-label="Add checklist"
            className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            onClick={() => handleAddBlock(BLOCK_TYPES.CHECKLIST)}
            title="Add checklist"
          >
            <CheckSquare className="w-4 h-4" />
          </button>

          <button
            type="button"
            aria-label="Add image"
            className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            onClick={() => handleAddBlock(BLOCK_TYPES.IMAGE)}
            title="Add image"
          >
            <ImageIcon className="w-4 h-4" />
          </button>

          <button
            type="button"
            aria-label="Add drawing"
            className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            onClick={() => handleAddBlock(BLOCK_TYPES.DRAWING)}
            title="Add drawing"
          >
            <Edit3 className="w-4 h-4" />
          </button>
        </div>

        <div className="h-6 w-px bg-gray-300 dark:bg-gray-600"></div>

        {/* Actions */}
        <div className="flex items-center space-x-1">
          <button
            type="button"
            aria-label="Set reminder"
            className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            onClick={() => setShowReminderPicker(true)}
            title="Set reminder"
          >
            <Bell className="w-4 h-4" />
          </button>

          <button
            type="button"
            aria-label="Add collaborators"
            className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            title="Add collaborators"
          >
            <UserPlus className="w-4 h-4" />
          </button>

          <button
            type="button"
            aria-label="Archive note"
            className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            title="Archive note"
          >
            <Archive className="w-4 h-4" />
          </button>

          <div className="relative">
            <button
              type="button"
              aria-label="More options"
              className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
                }`}
              title="More options"
              onClick={() => setShowMoreOptions((prev) => !prev)}
            >
              <MoreVertical className="w-4 h-4" />
            </button>

            {showMoreOptions && (
              <div className={`absolute right-0 mt-2 w-48 rounded-md shadow-lg z-50 ${darkMode ? 'bg-gray-800' : 'bg-white'
                }`}>
                <button
                  className={`flex items-center w-full px-4 py-2 text-sm ${darkMode ? 'text-red-400 hover:bg-gray-700' : 'text-red-600 hover:bg-gray-100'
                    }`}
                  onClick={() => {
                    if (window.confirm('Are you sure you want to delete this note?')) {
                      onDelete?.(note.id);
                    }
                    setShowMoreOptions(false);
                  }}
                >
                  <Trash2 className="w-4 h-4 mr-2" />
                  Delete
                </button>
              </div>
            )}
          </div>
        </div>

        <div className="h-6 w-px bg-gray-300 dark:bg-gray-600"></div>

        {/* Undo/Redo */}
        <div className="flex items-center space-x-1">
          <button
            type="button"
            aria-label="Undo"
            className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            title="Undo"
          >
            <Undo className="w-4 h-4" />
          </button>

          <button
            type="button"
            aria-label="Redo"
            className={`p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
              }`}
            title="Redo"
          >
            <Redo className="w-4 h-4" />
          </button>
        </div>

        {/* Close button */}
        <button
          type="button"
          aria-label="Close"
          className={`ml-auto p-2 rounded-full transition ${darkMode ? 'hover:bg-gray-700 text-gray-300' : 'hover:bg-gray-200 text-gray-700'
            }`}
          onClick={() => onCancel?.()}
          title="Close"
        >
          <X className="w-4 h-4" />
        </button>
      </div>

      {/* Reminder Picker */}
      {showReminderPicker && (
        <div className={`absolute top-full left-0 mt-2 flex items-start justify-start z-50`}>
          <div className={`w-64 rounded-md shadow-lg p-4 ${darkMode ? 'bg-gray-900 text-gray-100 ring-1 ring-white ring-opacity-20' : 'bg-gray-50 text-gray-900 ring-1 ring-black ring-opacity-5'
            }`} style={{ zIndex: 1000 }}>
            <h3 className="font-medium mb-2">Set reminder</h3>
            <ReminderPicker
              reminder={note.reminder}
              setReminder={handleSetReminder}
              onClose={() => setShowReminderPicker(false)}
            />
          </div>
        </div>
      )}

      {/* Labels Modal */}
      {editLabelsModalOpen && createPortal(
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={() => setEditLabelsModalOpen(false)}>
          <div className={`rounded-lg p-6 max-w-md w-full ${darkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-800'
            }`} onClick={(e) => e.stopPropagation()}>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium">Edit Labels</h3>
              <button
                onClick={() => setEditLabelsModalOpen(false)}
                className="text-gray-500 hover:text-gray-700"
              >
                ×
              </button>
            </div>

            <div className="max-h-60 overflow-y-auto">
              {selectedLabels.map(label => (
                <div
                  key={label.id}
                  className="flex items-center p-2 hover:bg-gray-200 dark:hover:bg-gray-700 rounded cursor-pointer"
                  onClick={() => {
                    setSelectedLabels(prev =>
                      prev.includes(label)
                        ? prev.filter(l => l.id !== label.id)
                        : [...prev, label]
                    );
                  }}
                >
                  <input
                    type="checkbox"
                    checked={selectedLabels.some(l => l.id === label.id)}
                    className="mr-2"
                    readOnly
                  />
                  <span>{label.name}</span>
                </div>
              ))}
            </div>

            <div className="flex justify-end mt-4 space-x-2">
              <button
                onClick={() => setEditLabelsModalOpen(false)}
                className="px-4 py-2 rounded hover:bg-gray-200 dark:hover:bg-gray-700"
              >
                Cancel
              </button>
              <button
                onClick={() => {
                  handleLabelsChange(selectedLabels);
                  setEditLabelsModalOpen(false);
                }}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
              >
                Save
              </button>
            </div>
          </div>
        </div>,
        document.body
      )}

      {/* Action bar (hover only) */}
      <ActionBar
        note={note}
        setNote={setNote}
        onDelete={onDelete}
        onCancel={onCancel}
        darkMode={darkMode}
        setShowReminderPicker={setShowReminderPicker}
        setEditLabelsModalOpen={setEditLabelsModalOpen}
      />
    </div>
  );
}

/*****************************************************************
 * Title field - Using textarea instead of contentEditable
 *****************************************************************/
function TitleField({ value, onChange, darkMode }) {
  const [internalValue, setInternalValue] = useState(value);
  const textareaRef = useRef(null);

  // Update internal value when prop changes
  useEffect(() => {
    setInternalValue(value);
  }, [value]);

  const handleChange = (e) => {
    const newValue = e.target.value;
    setInternalValue(newValue);
    onChange(newValue);
  };

  // Auto-resize textarea
  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  }, [internalValue]);

  return (
    <textarea
      ref={textareaRef}
      value={internalValue}
      onChange={handleChange}
      placeholder="Title"
      rows={1}
      className={clsx(
        'text-2xl font-bold outline-none w-full resize-none overflow-hidden bg-transparent',
        darkMode ? 'text-white placeholder-gray-500' : 'text-gray-900 placeholder-gray-500'
      )}
      style={{ minHeight: '1.5em', direction: 'ltr' }}
    />
  );
}

/*****************************************************************
 * Block dispatcher
 *****************************************************************/
function Block({ block, onUpdate, onRemove, onSplit, darkMode, formatting }) {
  switch (block.type) {
    case BLOCK_TYPES.TEXT:
      return <TextBlock
        data={block.data}
        onUpdate={onUpdate}
        onSplit={onSplit}
        darkMode={darkMode}
        formatting={formatting}
      />;
    case BLOCK_TYPES.CHECKLIST:
      return <ChecklistBlock data={block.data} onUpdate={onUpdate} darkMode={darkMode} />;
    case BLOCK_TYPES.IMAGE:
      return <ImageBlock data={block.data} onUpdate={onUpdate} onRemove={onRemove} darkMode={darkMode} />;
    case BLOCK_TYPES.DRAWING:
      return <DrawingBlock data={block.data} onUpdate={onUpdate} onRemove={onRemove} darkMode={darkMode} />;
    default:
      return null;
  }
}

/*****************************************************************
 * Text block - Using textarea instead of contentEditable
 *****************************************************************/
function TextBlock({ data, onUpdate, onSplit, darkMode, formatting }) {
  const [internalData, setInternalData] = useState(data);
  const textareaRef = useRef(null);

  // Update internal data when prop changes
  useEffect(() => {
    setInternalData(data);
  }, [data]);

  const handleChange = (e) => {
    const newValue = e.target.value;
    setInternalData(newValue);
    onUpdate(newValue);
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      const cursorPosition = e.target.selectionStart;
      const before = internalData.slice(0, cursorPosition);
      const after = internalData.slice(cursorPosition);
      onUpdate(before);
      onSplit(after);
    }
  };

  // Auto-resize textarea
  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  }, [internalData]);

  return (
    <textarea
      ref={textareaRef}
      value={internalData}
      onChange={handleChange}
      onKeyDown={handleKeyDown}
      placeholder="Take a note…"
      rows={1}
      className={clsx(
        'outline-none w-full resize-none overflow-hidden bg-transparent',
        darkMode ? 'text-gray-100 placeholder-gray-500' : 'text-gray-900 placeholder-gray-500',
        formatting.bold && 'font-bold',
        formatting.italic && 'italic',
        formatting.underline && 'underline'
      )}
      style={{ minHeight: '1.5em', direction: 'ltr' }}
    />
  );
}

/*****************************************************************
 * Checklist block
 *****************************************************************/
function ChecklistBlock({ data, onUpdate, darkMode }) {
  const toggle = (i) =>
    onUpdate(data.map((it, idx) => (idx === i ? { ...it, checked: !it.checked } : it)));

  const changeText = (i, text) =>
    onUpdate(data.map((it, idx) => (idx === i ? { ...it, text } : it)));

  const add = () => onUpdate([...data, { id: generateId(), text: '', checked: false }]);

  const remove = (i) => onUpdate(data.filter((_, idx) => idx !== i));

  return (
    <div className="space-y-2 w-full">
      {data.map((it, idx) => (
        <label key={it.id} className="flex items-center space-x-2 cursor-pointer">
          <input
            type="checkbox"
            checked={it.checked}
            onChange={() => toggle(idx)}
            className="rounded-sm"
          />
          <input
            type="text"
            value={it.text}
            onChange={(e) => changeText(idx, e.target.value)}
            placeholder="List item"
            className={`flex-grow bg-transparent border-none outline-none ${darkMode ? 'text-gray-100 placeholder-gray-400' : 'text-gray-900 placeholder-gray-500'
              }`}
            style={{ direction: 'ltr' }}
          />
          <button
            onClick={() => remove(idx)}
            className={`p-1 rounded-full ${darkMode ? 'text-gray-400 hover:bg-gray-700' : 'text-gray-500 hover:bg-gray-200'
              }`}
          >
            <X className="w-4 h-4" />
          </button>
        </label>
      ))}
      <button
        onClick={add}
        className={`flex items-center text-sm ${darkMode ? 'text-blue-400 hover:text-blue-300' : 'text-blue-600 hover:text-blue-500'
          }`}
      >
        <Plus className="w-4 h-4 mr-1" /> Add item
      </button>
    </div>
  );
}

/*****************************************************************
 * Image block
 *****************************************************************/
function ImageBlock({ data, onUpdate, onRemove, darkMode }) {
  const inputRef = useRef();

  const handleUpload = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    onUpdate({ file, url });
  };

  return (
    <div className="relative group w-full">
      {data?.url ? (
        <>
          <img
            src={data.url}
            alt=""
            className="rounded-md w-full max-h-60 object-cover"
          />
          <button
            onClick={onRemove}
            className={`absolute top-2 right-2 rounded-full p-1 ${darkMode ? 'bg-black/70 text-white' : 'bg-white/70 text-gray-800'
              } opacity-0 group-hover:opacity-100 transition`}
          >
            <X className="w-4 h-4" />
          </button>
        </>
      ) : (
        <div
          className={`w-full h-40 border-2 border-dashed rounded-md flex flex-col items-center justify-center cursor-pointer ${darkMode ? 'border-gray-600 text-gray-400 hover:border-gray-500' : 'border-gray-300 text-gray-500 hover:border-gray-400'
            }`}
          onClick={() => inputRef.current?.click()}
        >
          <ImageIcon className="w-8 h-8 mb-2" />
          <span>Add image</span>
        </div>
      )}
      <input ref={inputRef} type="file" accept="image/*" onChange={handleUpload} className="hidden" />
    </div>
  );
}

/*****************************************************************
 * Drawing block
 *****************************************************************/
function DrawingBlock({ data, onUpdate, onRemove, darkMode }) {
  const canvasRef = useRef();
  const [ctx, setCtx] = useState(null);
  const [drawing, setDrawing] = useState(false);

  useEffect(() => {
    const c = canvasRef.current;
    if (!c) return;
    const context = c.getContext('2d');
    setCtx(context);
    if (data?.image) {
      const img = new Image();
      img.onload = () => context.drawImage(img, 0, 0);
      img.src = data.image;
    }
  }, [data]);

  const start = (e) => {
    setDrawing(true);
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    ctx.beginPath();
    ctx.moveTo(x, y);
  };

  const draw = (e) => {
    if (!drawing) return;
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    ctx.lineTo(x, y);
    ctx.stroke();
  };

  const stop = () => {
    if (!drawing) return;
    setDrawing(false);
    onUpdate({ image: canvasRef.current.toDataURL() });
  };

  const clear = () => {
    ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
    onUpdate({ image: null });
  };

  return (
    <div className="relative group w-full">
      <canvas
        ref={canvasRef}
        width="100%"
        height="200"
        className={`w-full touch-none rounded-md ${darkMode ? 'bg-gray-900' : 'bg-gray-100'
          }`}
        onMouseDown={start}
        onMouseMove={draw}
        onMouseUp={stop}
        onMouseLeave={stop}
      />
      <div className="absolute top-2 right-2 flex space-x-1 opacity-0 group-hover:opacity-100 transition">
        <button
          onClick={clear}
          className={`rounded-full p-1 ${darkMode ? 'bg-black/70 text-white' : 'bg-white/70 text-gray-800'
            }`}
        >
          <Trash2 className="w-4 h-4" />
        </button>
        <button
          onClick={onRemove}
          className={`rounded-full p-1 ${darkMode ? 'bg-black/70 text-white' : 'bg-white/70 text-gray-800'
            }`}
        >
          <X className="w-4 h-4" />
        </button>
      </div>
    </div>
  );
}

/*****************************************************************
 * Hover "+" between blocks
 *****************************************************************/
function AddBetween({ index, onAdd, darkMode }) {
  const [show, setShow] = useState(false);

  return (
    <div
      className="relative h-6 flex justify-center items-center"
      onMouseEnter={() => setShow(true)}
      onMouseLeave={() => setShow(false)}
    >
      {show && (
        <div className="flex space-x-1">
          <button
            onClick={() => onAdd(BLOCK_TYPES.TEXT)}
            className={`w-6 h-6 rounded-full flex items-center justify-center ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700'
              }`}
            title="Add text"
          >
            <Type className="w-3 h-3" />
          </button>
          <button
            onClick={() => onAdd(BLOCK_TYPES.CHECKLIST)}
            className={`w-6 h-6 rounded-full flex items-center justify-center ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700'
              }`}
            title="Add checklist"
          >
            <CheckSquare className="w-3 h-3" />
          </button>
          <button
            onClick={() => onAdd(BLOCK_TYPES.IMAGE)}
            className={`w-6 h-6 rounded-full flex items-center justify-center ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700'
              }`}
            title="Add image"
          >
            <ImageIcon className="w-3 h-3" />
          </button>
          <button
            onClick={() => onAdd(BLOCK_TYPES.DRAWING)}
            className={`w-6 h-6 rounded-full flex items-center justify-center ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700'
              }`}
            title="Add drawing"
          >
            <Edit3 className="w-3 h-3" />
          </button>
        </div>
      )}
    </div>
  );
}

/*****************************************************************
 * Action bar (hover only)
 *****************************************************************/
function ActionBar({ note, setNote, onDelete, onCancel, darkMode }) {
  return null;
}